# PostgreSQL Tuning for PGQueuer

High-throughput queues can generate a lot of write activity. Without tuning, PostgreSQL's Write-Ahead Log (WAL) may become a bottleneck. This guide covers common settings that help reduce WAL pressure and improve throughput.

## Unlogged Tables

For ephemeral workloads where the queue contents can be recreated, use unlogged tables to avoid WAL writes entirely. Install PGQueuer with the `--durability volatile` flag:

```bash
pgq install --durability volatile
```

This mode roughly halves the amount of WAL generated by queue operations. Data is lost if the database crashes, so only enable it when that trade-off is acceptable.

When tables are unlogged, queue operations bypass the WAL entirely. Tuning
parameters such as ``max_wal_size`` and ``checkpoint_timeout`` therefore have
little effect on PGQueuer itself, though they may still matter for other tables
in the same database. The rest of this guide focuses on durable (logged) tables
where WAL volume is a concern.

## WAL and Checkpoint Parameters

When durability is required, increase the WAL and checkpoint thresholds to reduce how often PostgreSQL flushes pages. Example settings in `postgresql.conf`:

```conf
max_wal_size = 2GB
checkpoint_timeout = 30min
wal_buffers = 16MB
```

These values smooth out I/O spikes caused by frequent checkpoints when processing many small jobs.

## Batch Inserts and Acknowledgements

Enqueue or acknowledge jobs in batches whenever possible. Committing hundreds of jobs per transaction greatly reduces WAL fsync overhead. Both `Queries.enqueue` and `Queries.dequeue` accept batch lists.

## Keep the Active Queue Small

PGQueuer moves completed jobs to a log table. Regularly prune old log entries so the working set stays in memory. A small hot table keeps inserts and updates fast and avoids extra WAL traffic from vacuum.

## Partition and Truncate Logs

If long-term history is required, consider partitioning the log table (for example by day) and truncating or dropping old partitions in bulk. This prevents autovacuum from churning through millions of dead rows and keeps WAL usage predictable.

## Synchronous Commit

For non-critical tasks you can disable synchronous commit to avoid forcing WAL to disk on every transaction:

```conf
synchronous_commit = off
```

This provides a throughput boost at the cost of a small window where recent jobs may be lost if the database crashes.

These recommendations are starting pointsâ€”benchmark with your workload to find the best values. Well-tuned WAL parameters combined with batching and housekeeping can yield substantial improvements in throughput.
